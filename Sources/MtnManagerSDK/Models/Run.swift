//
// Run.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** Represents a single run at the resort with its current status,  grooming information, and difficulty rating. */
public struct Run: Sendable, Codable, Hashable {

    /** Unique identifier for the run. */
    public var uuid: String
    /** Display name of the run. */
    public var name: String
    /** URL-friendly name of the run. */
    public var slug: String
    /** Optional run number. */
    public var number: Int?
    /** Difficulty rating of the run. */
    public var difficulty: RunDifficulty
    /** Current operational status (open, closed, or unknown). */
    public var status: RunStatus
    /** When the run was last groomed.  `null` if never groomed, or if the runs grooming feature is disabled. */
    public var lastGroomed: Date?
    /** Whether the run was groomed within the last 24 hours. */
    public var groomedToday: Bool
    /** Whether the run has snowmaking capabilities. */
    public var snowmaking: Bool
    /** Whether the run is available for night skiing. */
    public var nightSkiing: Bool
    /** Notes about current conditions on this run. */
    public var conditionNotes: String
    /** UUID of the area this run belongs to, if assigned. */
    public var areaUuid: String?
    /** Name of the area this run belongs to, if assigned. */
    public var areaName: String?
    /** Display order of the area this run belongs to, if assigned, for sorting purposes. */
    public var areaDisplayOrder: Int?
    /** When this run's information was last updated. */
    public var updatedAt: Date

    public init(uuid: String, name: String, slug: String, number: Int? = nil, difficulty: RunDifficulty, status: RunStatus, lastGroomed: Date? = nil, groomedToday: Bool, snowmaking: Bool, nightSkiing: Bool, conditionNotes: String, areaUuid: String? = nil, areaName: String? = nil, areaDisplayOrder: Int? = nil, updatedAt: Date) {
        self.uuid = uuid
        self.name = name
        self.slug = slug
        self.number = number
        self.difficulty = difficulty
        self.status = status
        self.lastGroomed = lastGroomed
        self.groomedToday = groomedToday
        self.snowmaking = snowmaking
        self.nightSkiing = nightSkiing
        self.conditionNotes = conditionNotes
        self.areaUuid = areaUuid
        self.areaName = areaName
        self.areaDisplayOrder = areaDisplayOrder
        self.updatedAt = updatedAt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case uuid
        case name
        case slug
        case number
        case difficulty
        case status
        case lastGroomed = "last_groomed"
        case groomedToday = "groomed_today"
        case snowmaking
        case nightSkiing = "night_skiing"
        case conditionNotes = "condition_notes"
        case areaUuid = "area_uuid"
        case areaName = "area_name"
        case areaDisplayOrder = "area_display_order"
        case updatedAt = "updated_at"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(uuid, forKey: .uuid)
        try container.encode(name, forKey: .name)
        try container.encode(slug, forKey: .slug)
        try container.encodeIfPresent(number, forKey: .number)
        try container.encode(difficulty, forKey: .difficulty)
        try container.encode(status, forKey: .status)
        try container.encodeIfPresent(lastGroomed, forKey: .lastGroomed)
        try container.encode(groomedToday, forKey: .groomedToday)
        try container.encode(snowmaking, forKey: .snowmaking)
        try container.encode(nightSkiing, forKey: .nightSkiing)
        try container.encode(conditionNotes, forKey: .conditionNotes)
        try container.encodeIfPresent(areaUuid, forKey: .areaUuid)
        try container.encodeIfPresent(areaName, forKey: .areaName)
        try container.encodeIfPresent(areaDisplayOrder, forKey: .areaDisplayOrder)
        try container.encode(updatedAt, forKey: .updatedAt)
    }
}

