//
// SnowReport.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** Provides current snow conditions for a specific area or the entire resort,  including base depth, surface conditions, and snowfall totals in both  metric and imperial units. */
public struct SnowReport: Sendable, Codable, Hashable {

    /** Unique identifier for this snow report. */
    public var uuid: String
    /** UUID of the area this report covers, if area-specific.  `null` for resort-wide reports. */
    public var areaUuid: String?
    /** Name of the area this report covers, if area-specific. */
    public var areaName: String?
    /** Display order of the area this report covers, if area-specific, for sorting purposes. */
    public var areaDisplayOrder: Int?
    /** Current base depth in centimeters.  Not included if the base depth feature is disabled. */
    public var baseDepthCm: Int?
    /** Current base depth in inches.  Not included if the base depth feature is disabled. */
    public var baseDepthIn: Int?
    public var surfaceCondition: SurfaceCondition?
    public var secondarySurfaceCondition: SurfaceCondition?
    /** Additional notes about current snow conditions, e.g. groomer's notes */
    public var conditionNotes: String
    /** Snowfall accumulation metrics in centimeters. */
    public var snowfallCm: SnowMetrics
    /** Snowfall accumulation metrics in inches. */
    public var snowfallIn: SnowMetrics
    /** When this snow report was last updated. */
    public var reportedAt: Date

    public init(uuid: String, areaUuid: String? = nil, areaName: String? = nil, areaDisplayOrder: Int? = nil, baseDepthCm: Int? = nil, baseDepthIn: Int? = nil, surfaceCondition: SurfaceCondition? = nil, secondarySurfaceCondition: SurfaceCondition? = nil, conditionNotes: String, snowfallCm: SnowMetrics, snowfallIn: SnowMetrics, reportedAt: Date) {
        self.uuid = uuid
        self.areaUuid = areaUuid
        self.areaName = areaName
        self.areaDisplayOrder = areaDisplayOrder
        self.baseDepthCm = baseDepthCm
        self.baseDepthIn = baseDepthIn
        self.surfaceCondition = surfaceCondition
        self.secondarySurfaceCondition = secondarySurfaceCondition
        self.conditionNotes = conditionNotes
        self.snowfallCm = snowfallCm
        self.snowfallIn = snowfallIn
        self.reportedAt = reportedAt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case uuid
        case areaUuid = "area_uuid"
        case areaName = "area_name"
        case areaDisplayOrder = "area_display_order"
        case baseDepthCm = "base_depth_cm"
        case baseDepthIn = "base_depth_in"
        case surfaceCondition = "surface_condition"
        case secondarySurfaceCondition = "secondary_surface_condition"
        case conditionNotes = "condition_notes"
        case snowfallCm = "snowfall_cm"
        case snowfallIn = "snowfall_in"
        case reportedAt = "reported_at"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(uuid, forKey: .uuid)
        try container.encodeIfPresent(areaUuid, forKey: .areaUuid)
        try container.encodeIfPresent(areaName, forKey: .areaName)
        try container.encodeIfPresent(areaDisplayOrder, forKey: .areaDisplayOrder)
        try container.encodeIfPresent(baseDepthCm, forKey: .baseDepthCm)
        try container.encodeIfPresent(baseDepthIn, forKey: .baseDepthIn)
        try container.encodeIfPresent(surfaceCondition, forKey: .surfaceCondition)
        try container.encodeIfPresent(secondarySurfaceCondition, forKey: .secondarySurfaceCondition)
        try container.encode(conditionNotes, forKey: .conditionNotes)
        try container.encode(snowfallCm, forKey: .snowfallCm)
        try container.encode(snowfallIn, forKey: .snowfallIn)
        try container.encode(reportedAt, forKey: .reportedAt)
    }
}

