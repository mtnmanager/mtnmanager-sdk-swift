//
// Schedule.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** Recurring schedule pattern with human-readable and machine-readable formats.   Describes a regular operating schedule (e.g., \&quot;Weekends 10am-4pm\&quot;) with  both formatted strings for display and structured data for programmatic use. */
public struct Schedule: Sendable, Codable, Hashable {

    public static let opensAtRule = StringRule(minLength: nil, maxLength: nil, pattern: "/^([01]\\d|2[0-3]):[0-5]\\d$/")
    public static let closesAtRule = StringRule(minLength: nil, maxLength: nil, pattern: "/^([01]\\d|2[0-3]):[0-5]\\d$/")
    /** Human-readable description of which days this schedule applies to.  Examples: \"Daily\", \"Saturday & Sunday\", \"Monday, Wednesday, and Friday\" */
    public var daysString: String
    /** Array of days of the week this schedule applies to.  For programmatic use. */
    public var daysOfWeek: [DayOfWeek]
    /** Human-readable time range.  Example: \"9:00 a.m. to 4:00 p.m.\" */
    public var timeString: String
    /** Opening time in 24-hour format (HH:MM), in resort's local timezone. */
    public var opensAt: String
    /** Closing time in 24-hour format (HH:MM), in resort's local timezone. */
    public var closesAt: String
    /** Whether this schedule is currently in effect.  `false` for upcoming schedules that haven't started yet. */
    public var inEffect: Bool
    /** Human-readable date range when this schedule is effective.  Example: \"November 1, 2024 to April 15, 2025\" */
    public var effectiveString: String
    /** Start date of the effective period (YYYY-MM-DD). */
    public var effectiveFrom: Date
    /** End date of the effective period (YYYY-MM-DD). */
    public var effectiveTo: Date

    public init(daysString: String, daysOfWeek: [DayOfWeek], timeString: String, opensAt: String, closesAt: String, inEffect: Bool, effectiveString: String, effectiveFrom: Date, effectiveTo: Date) {
        self.daysString = daysString
        self.daysOfWeek = daysOfWeek
        self.timeString = timeString
        self.opensAt = opensAt
        self.closesAt = closesAt
        self.inEffect = inEffect
        self.effectiveString = effectiveString
        self.effectiveFrom = effectiveFrom
        self.effectiveTo = effectiveTo
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case daysString = "days_string"
        case daysOfWeek = "days_of_week"
        case timeString = "time_string"
        case opensAt = "opens_at"
        case closesAt = "closes_at"
        case inEffect = "in_effect"
        case effectiveString = "effective_string"
        case effectiveFrom = "effective_from"
        case effectiveTo = "effective_to"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(daysString, forKey: .daysString)
        try container.encode(daysOfWeek, forKey: .daysOfWeek)
        try container.encode(timeString, forKey: .timeString)
        try container.encode(opensAt, forKey: .opensAt)
        try container.encode(closesAt, forKey: .closesAt)
        try container.encode(inEffect, forKey: .inEffect)
        try container.encode(effectiveString, forKey: .effectiveString)
        try container.encode(effectiveFrom, forKey: .effectiveFrom)
        try container.encode(effectiveTo, forKey: .effectiveTo)
    }
}

